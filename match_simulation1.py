# -*- coding: utf-8 -*-
"""Match_simulation1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JlAC1mnc4GHpX6ZUDTGJkWaaIKnN7oHe

##Match Simulation Framework
"""

#for working with dataframes
import numpy as np
import pandas as pd
from google.colab import drive
#for getting the combination of squad
from itertools import combinations
drive.mount('/content/gdrive')
loc = '/content/gdrive/MyDrive/'
loc1 = loc#base dir
loc_df =  loc+'match_simulation_results/'#match simulation results folder
#team pattern csv files location:
loc3 = loc+'team_patterns/'
pd.set_option('display.max_rows', 50000)
pd.set_option('display.max_columns', 5000)
pd.set_option('display.width', 1000)

# Commented out IPython magic to ensure Python compatibility.
# %cd "/content/gdrive/MyDrive/Colab Notebooks/"
!pip install import-ipynb
import import_ipynb
#the base model for ball by ball prediction file
from sample_model import match_simulator_model
#the py file for the player form attributes used in the model:
from derived_attributes_new import form_batsmen,form_bowler,venue_bowler,venue_batsmen,opposition_bowler,opposition_batsmen,consistency_bowler,consistency_batsmen

#for selecting 15players from each squad:
from squad_15_players import filter_15_players

#required csv files:
df2 = pd.read_csv(loc1+'player_info_unique_new.csv')#player information file ,for filtering role
df = pd.read_csv(loc+'ball_ball_new6.csv')#ball by ball dataset
bat_clus = pd.read_csv(loc+'rfm_bat_cluster_updated.csv')#rfm batting year wise cluster csv file
bowl_clus = pd.read_csv(loc+'rfm_bowl_cluster_updated.csv')#rfm year wise bowling csv file

df.head()

#function to get the comlbination of 11 players in a team squad
#input is a list of 24 players in the squad along with the squad bench
def team_combinations(team1_squad):
  com = combinations(team1_squad,11)#generates the possible combination of 11 players
  t1_s = []#the combination of squad is saved here
  for i in list(com):
    t1_s.append(i)
  return t1_s

#function to get the player main role:
#the input is the specific player role:
def pl_role_sub(x):
  bats = ['top-order batter','batter','middle-order batter','opening batter']
  bowl = ['bowler']
  ar = ['allrounder','batting allrounder','bowling allrounder']
  wk = ['wicketkeeper','wicketkeeper batter']
  if x in bats:
    return 'batsman'
  elif x in bowl:
    return 'bowler'
  elif x in ar:
    return 'allrounder'
  elif x in wk:
    return 'wicketkeeper'

#function to generate the valid team combinations:
#the input of this function is the team squad and the team name:
def team_comb(team_squad,team_name):
    #generating all the possible 11 combination
    team_combs = team_combinations(team_squad)
    team_combs = team_combs
    #player role is stored here
    t1role = []
    for i in team_squad:
      dv = df2[(df2.alpha_name == i)|(df2.card_long == i)|(df2.card_short == i)|(df2.known_as == i)|(df2.mobile_name == i)|(df2.popular_name == i)]
      if len(dv) == 0:
        t1role.append(None)
      else:
        t1role.append(dv['player_primary_role'].iloc[0])
    #squad df is generated
    t_df = pd.DataFrame({'squad':team_squad,'role':t1role})
    t_df = t_df.dropna()
    t_df['role1'] = t_df['role'].apply(lambda x: pl_role_sub(x))
    #team name is required for importing the team's playing pattern
    team_name = team_name.lower()
    try:
        tm_df = pd.read_csv(loc3+team_name+'.csv')
        patterns = list(tm_df.squad_pat.unique())
    except:
        #if the team pattern file is not found then this static list of patterns is followed
        patterns = [4421, 542, 5411, 5321, 2342, 3341, 5222, 4322, 3332, 4331, 
       2432, 2441, 443, 632, 533, 6221, 6311,641]
    #the list of valid squad is saved in this list:
    finalised_t1_sq = []
    #each team combination is being checked with each of the pattern and if both the team pattern and the combination is valid then the squad combination is saved in the list.
    for i in team_combs:
        for pattern in patterns:
            role = []
            for k in i:
              cm = t_df[t_df.squad == k]
              try:
                role.append(cm['role1'].iloc[0])
              except:
                pass
            bat = 0
            bow = 0
            ar = 0
            wk = 0
            for ml in role:
              if ml == 'batsman':
                bat+=1
              elif ml == 'bowler':
                bow+=1
              elif ml == 'wicketkeeper':
                wk+=1
              elif ml == 'allrounder':
                ar+=1
            if wk != 0:
                new_pat = str(bat)+str(bow)+str(ar)+str(wk)
            else:
                new_pat = str(bat)+str(bow)+str(ar)
            if str(pattern) == str(new_pat):
              finalised_t1_sq.append(i)
            else:
              pass
            if len(finalised_t1_sq) >= 5:
              break
    if len(finalised_t1_sq) != 0:
      return finalised_t1_sq
    else:
      patterns = [4421, 542, 5411, 5321, 2342, 3341, 5222, 4322, 3332, 4331, 
       2432, 2441, 443, 632, 533, 6221, 6311,641]
      #the list of valid squad is saved in this list:
      finalised_t1_sq = []
      #each team combination is being checked with each of the pattern and if both the team pattern and the combination is valid then the squad combination is saved in the list.
      for i in team_combs:
          for pattern in patterns:
              role = []
              for k in i:
                cm = t_df[t_df.squad == k]
                try:
                  role.append(cm['role1'].iloc[0])
                except:
                  pass
              bat = 0
              bow = 0
              ar = 0
              wk = 0
              for ml in role:
                if ml == 'batsman':
                  bat+=1
                elif ml == 'bowler':
                  bow+=1
                elif ml == 'wicketkeeper':
                  wk+=1
                elif ml == 'allrounder':
                  ar+=1
              if wk != 0:
                  new_pat = str(bat)+str(bow)+str(ar)+str(wk)
              else:
                  new_pat = str(bat)+str(bow)+str(ar)
              if str(pattern) == str(new_pat):
                finalised_t1_sq.append(i)
              else:
                pass
              if len(finalised_t1_sq) >= 5:
                break
    return finalised_t1_sq[0:5]

#function to get the current position of both the batsmans and the bowler:
#the input for this function is the ball result,ball number,over number,player in strike,non striker,bowler,the battig order of the batting team and the bowling order of the bowling team.
def player_status(ball_result,ball_number,over_no,striker,non_striker,bowler,bat_order,bowl_order):
    if ball_number != 6:
    #if the ball is not the last ball of the over,then these conditions are executed:
        if ball_result == '0':
            new_striker = striker
            new_non_striker = non_striker
            new_bowler = bowler
        elif ball_result == '1':
            new_striker = non_striker
            new_non_striker = striker
            new_bowler = bowler
        elif ball_result == '2':
            new_striker = striker
            new_non_striker = non_striker
            new_bowler = bowler
        elif ball_result == '3':
            new_striker = non_striker
            new_non_striker = striker
            new_bowler = bowler
        elif ball_result == '4':
            new_striker = striker
            new_non_striker = non_striker
            new_bowler = bowler
        elif ball_result == '6':
            new_striker = striker
            new_non_striker = non_striker
            new_bowler = bowler
        elif ball_result == 'W':
            new_striker = bat_order[0]
            new_non_striker = non_striker
            new_bowler = bowler
        
    else:
    #if its the last ball of the over then these conditions are executed.
        if ball_result == '0':
            new_striker = non_striker
            new_non_striker = striker
            new_bowler = bowl_order[0]
        elif ball_result == '1':
            new_striker = striker
            new_non_striker = non_striker
            new_bowler = bowl_order[0]
        elif ball_result == '2':
            new_striker = non_striker
            new_non_striker = striker
            new_bowler = bowl_order[0]
        elif ball_result == '3':
            new_striker = striker
            new_non_striker = non_striker
            new_bowler = bowl_order[0]
        elif ball_result == '4':
            new_striker = non_striker
            new_non_striker = striker
            new_bowler = bowl_order[0]
        elif ball_result == '6':
            new_striker = non_striker
            new_non_striker = striker
            new_bowler = bowl_order[0]
        elif ball_result == 'W':
            new_striker = non_striker
            new_non_striker = bat_order[0]
            new_bowler = bowl_order[0]
    #this function returns the new striker,non striker and the bowler       
    return new_striker,new_non_striker,new_bowler

#function to get the categorical ball result into actual runs:
def ball_result_cat(ball_result):
    if ball_result == '1':
        return 1
    elif ball_result == '0':
        return 0
    elif ball_result == '2':
        return 2
    elif ball_result == '3':
        return 3
    elif ball_result == '4':
        return 4
    elif ball_result == '6':
        return 6
    elif ball_result == 'W':
        return 0

#function to get the player bat stats from past performances,using the ball by ball dataset:
#df2 here is the player_info_unique.csv file which has the player info.
def bat_stats(x):
  dv = df2[(df2.alpha_name == x)|(df2.card_long == x)|(df2.card_short == x)|(df2.known_as == x)|(df2.mobile_name == x)|(df2.popular_name == x)]
  if len(dv) == 0:
    df1 = df[df.Striker == x]
  else:
    #the short name of the player is obtained and subsetted
    sht = dv['card_long'].iloc[0]
    df1 = df[(df.Striker == x)|(df.Striker == sht)]

  try:
    #the average runs with matches played is calculated.
    b = sum(df1.Run)/len(df1.ESPN_ID.unique())
  except:
    b = 0
  #the average runs is returned
  return b

#function to get the bowler stats in his past performance using the ball by ball dataset:
#the df2 variable is the player_info_unique.csv file :
def bowl_stats(x):
  #subsetting the df2 variable
  dv = df2[(df2.alpha_name == x)|(df2.card_long == x)|(df2.card_short == x)|(df2.known_as == x)|(df2.mobile_name == x)|(df2.popular_name == x)]
  if len(dv) == 0: 
    df1 = df[df.Bowler == x]
  else:
    #the card name of the player is obtained and subsetted:
    sht = dv['card_long'].iloc[0]
    df1 = df[(df.Bowler == x)|(df.Bowler == sht)]
  #the overs bowled in  each match is taken
  bb = []
  for i in df1.ESPN_ID.unique():
    cm = df1[df1.ESPN_ID == i]
    bm = len(cm)/6
    bb.append(bm)
  try:
    #the average overs is calculated
    avg_overs = sum(bb)/len(bb)
  except:
    avg_overs = 0
  if len(df1) == 0:
    powerplay = 0
    middle_overs = 0
    death_overs = 0
  else:
    #the phase wise bowler momentum is calculated
    cv = df1[df1.phase == 'power play']
    powerplay = sum(cv.Total_Run)/len(df1)
    cv = df1[df1.phase == 'middle over']
    middle_overs = sum(cv.Total_Run)/len(df1)
    cv = df1[df1.phase == 'death over']
    death_overs = sum(cv.Total_Run)/len(df1)
  #this function returns the average overs bowled by the bowler and his momentum during the powerplay,death and the middle overs of the game
  return avg_overs,powerplay,middle_overs,death_overs

#function to get the player role from the player_info_unique.csv file
#here df2 is the player_info_unique.csv file
def pl_role(x):
  #the dataframe is subsetted with the player name
  dv = df2[(df2.alpha_name == x)|(df2.card_long == x)|(df2.card_short == x)|(df2.known_as == x)|(df2.mobile_name == x)|(df2.popular_name == x)]
  if len(dv) == 0:
    return 0
  else:
    #condition to check if the player role is bowling:
    nm = dv['player_primary_role'].iloc[0]
    #the playing role in the ros list is able to bowl.hench we filter the role with this list
    ros = ['allrounder', 'bowler','bowling allrounder','middle-order batter','batting allrounder']
    if nm in ros:
      return 1
    else:
      return 0

#function to get the batting order of the team:
def bat_order(team_squad):
  #getting the players average runs scored:
  t1_st = [bat_stats(i) for i in team_squad]
  #creating a dataframe
  df_t1 = pd.DataFrame({'player':team_squad,'avg':t1_st})
  #sorting the dataframe with the average runs in decending order
  df_t1 = df_t1.sort_values(by = 'avg',ascending = False)
  #the batting order is assigned to players with the order of the players in the dataframe
  df_t1['bat_order'] = [i+1 for i in range(len(df_t1))]
  #the function returns the list of players in the batting order
  return list(df_t1.player)

#function to get the bowling players:
def bowl_order(team_squad):
  #the input of the function is the team squad
  t1_st = []
  pp = []
  mo = []
  do = []
  for i in team_squad:
    #for each player the bowling stats is calculated and saved in different lists
    v = bowl_stats(i)
    t1_st.append(v[0])
    pp.append(v[1])
    mo.append(v[2])
    do.append(v[3])
  #creating a dataframe for the bowlers:
  df_t1b = pd.DataFrame({'player':team_squad,'avg':t1_st,'powerplay':pp,'middle_overs':mo,'death_overs':do})
  df_t1b['role'] = [pl_role(i) for i in team_squad]
  #the dataframe is sorted with the average overs bowled and the rank of the bowler is assigned.
  df_t1b = df_t1b.sort_values(by = 'avg',ascending = False)
  df_t1b['bowl_order'] = [i+1 for i in range(len(df_t1b))]
  #the function returns the dataframe of the bowlers alonhg with the stats
  return df_t1b

#function to get the bowlers bowling order in the game:
#the input of the function is the bowling players dataframe along with their stats
def bowling_overs(team_bowl_order):
      #names of the bowlers are stored in order of bowling overs are stored here.
      bowl_overs = []
      #the static over pattern followed by teams:
      overs = [1,3,20,18,2,4,19,17,5,7,16,14,6,8,13,15,9,11,10,12]
      for i in range(len(team_bowl_order)):
          player = team_bowl_order.player.iloc[i]
          avg = team_bowl_order.avg.iloc[i]
          #the average overs bowled by the bowler is considered and the conditions are given as follows:
          if avg >= 3:
            avg = 4
          elif avg >= 1.1:
            avg = 2
          else:
            avg = 1
          for j in range(avg):
            bowl_overs.append(player)
      #a bowling order dataframe is created with the bowl_overs list and the first 20 names is considered:
      df = pd.DataFrame({'bowler':bowl_overs})
      df = df[0:20]
      #the overs is addigned and the dataframe is sorted with the over number in ascending order
      df['overs'] = overs
      df = df.sort_values(by = 'overs',ascending = True)
      #this function returns the list of bowlers for 20 overs.
      return list(df.bowler)

#function which randomly generates the toss and toss decision:
def toss(team1,team2):
    toss_winner = np.random.choice([team1,team2])
    toss_decision = np.random.choice(['bat','field'])
    text = toss_winner + ' team has won the toss and opted to '+toss_decision+'.'
    #returns the toss winner ,toss decision and the description.
    return {'toss_winner':toss_winner,'toss_decision':toss_decision,'description':text}

#function to get the six and four momentum of the players in a match:
#the input to the function is the match dataframe(ongoing match...)
def six_four_mom(df):
  #encoding the 6 and 4 runs
  f_c = []
  s_c = []
  for i in range(len(df)):
    run = df.Run.iloc[i]
    if run == 4:
      f_c.append(1)
    else:
      f_c.append(0)
    if run == 6:
      s_c.append(1)
    else:
      s_c.append(0)
  df['4_count'] = f_c
  df['6_count'] = s_c
  #the f_list stores the four momentum
  #the s_list stores the six momentum
  f_list = []
  s_list = []
  dic = {}
  for i in range(len(df)):
    print("left...",df.shape[0]-i)
    ids = df.ESPN_ID.iloc[i]
    stri = df.Striker.iloc[i]
    ov = df.Over_No.iloc[i]
    key = str(ids)+stri
    try:
      v = dic[key]
    except:
      v = df[df.ESPN_ID == ids]
      v = v[v.Striker == stri]
      dic[key] = v
    v = v[v.Over_No <= ov]
    f = 0
    li_4 = list(v['4_count'])
    #reversing the list and checking the number of fours
    li_4 = li_4[::-1]
    for k in li_4:
      if k == 0:
        break
      else:
        f+=1
    f_list.append(f)
    s = 0
    li_6 = list(v['6_count'])
    #reversing the list and checking the number of sixes
    li_6 = li_6[::-1]
    for m in li_6:
      if m == 0:
        break
      else:
        s+=1 
    s_list.append(s)
  #adding the six and four momentum as an attribute in the dataframe and returns the dataframe
  df['six_momentum'] = s_list
  df['four_momentum'] = f_list
  return df

#function to get the player info ,this function is used during the simulation
#the input of this function is the player name
def batsman_in_match_info(x):
  #the player info is subsetted using the player_info_unique.csv file
  dv = df2[(df2.alpha_name == x)|(df2.card_long == x)|(df2.card_short == x)|(df2.known_as == x)|(df2.mobile_name == x)|(df2.popular_name == x)]
  #the batting hand of the player is taken and categorically encoded
  bat_r = dv['batting_hand'].iloc[0]
  if bat_r == 'right-hand batter':
    S_Bat_left = 0
    S_Bat_right = 1
  elif bat_r == 'left-hand batter':
    S_Bat_left = 1
    S_Bat_right = 0
  else:
    S_Bat_left = 0
    S_Bat_right = 0
  #the age of the player is obtained
  batsman_age = dv['age_years'].iloc[0]
  #the primary role of the player is taken and categorically encoded
  batsman_primary_role = dv['player_primary_role']
  samp_dict = {None:0, 'top-order batter':1, 'allrounder':2, 'bowler':3, 'wicketkeeper':4,
       'batter':1, 'batting allrounder':2, 'middle-order batter':1,
       'wicketkeeper batter':4, 'opening batter':1, 'bowling allrounder':2}
  try:
    for key,val in samp_dict.items():
      if batsman_primary_role == key:
        batsman_primary_role = val
  except:
    batsman_primary_role = 0 
  #the function returns the categorical values of the batting hand,age,playing role.
  return S_Bat_left,S_Bat_right,batsman_age,batsman_primary_role

#function to get the player info ,this function is used during the simulation
#the input of this function is the player name
def bowler_in_match_info(x):
  #the player info is subsetted using the player_info_unique.csv file
  dv = df2[(df2.alpha_name == x)|(df2.card_long == x)|(df2.card_short == x)|(df2.known_as == x)|(df2.mobile_name == x)|(df2.popular_name == x)]
  #the bowling hand of the player is taken and categorically encoded
  bwl_arm = dv['bowling_hand'].iloc[0]
  if bwl_arm == 'left-arm bowler':
    bwl_Bow_left =  1
    bwl_Bow_right = 0
  elif bwl_arm == 'right-arm bowler':
    bwl_Bow_left =  0
    bwl_Bow_right = 1
  else:
    bwl_Bow_left =  0
    bwl_Bow_right = 0
  #the bowling type of the player is taken and categorically encoded.
  bwl_typ = dv['bowling_pacespin'].iloc[0]
  if bwl_typ == 'spin bowler':
    Bowler_pace = 0
    Bowler_spin = 1
  elif bwl_typ == 'pace bowler':
    Bowler_pace = 1
    Bowler_spin = 0
  else:
    Bowler_pace = 0
    Bowler_spin = 0
  #the age of the player is obtained
  bowler_age = dv['age_years'].iloc[0]
  bowler_bowling_style = dv['bowling_hand']
  #the primary role of the player is taken and categorically encoded
  bowler_primary_role = dv['player_primary_role']
  samp_dict = {'unknown arm':0, 'left-arm bowler':1, 'right-arm bowler':2}
  try:
    for key,val in samp_dict.items():
      if bowler_bowling_style == key:
        bowler_bowling_style = val
  except:
    bowler_bowling_style = 0
  samp_dict = {None:0, 'top-order batter':1, 'allrounder':2, 'bowler':3, 'wicketkeeper':4,
       'batter':1, 'batting allrounder':2, 'middle-order batter':1,
       'wicketkeeper batter':4, 'opening batter':1, 'bowling allrounder':2}
  try:
    for key,val in samp_dict.items():
      if bowler_primary_role == key:
        bowler_primary_role = val   
  except:
    bowler_primary_role = 0
  #the function returns the categorical values of the bowling hand,age,playing role and bowling style
  return bwl_Bow_left,bwl_Bow_right,Bowler_pace,Bowler_spin,bowler_age,bowler_bowling_style,bowler_primary_role

#function to get the actual result from the resut predicted by the ball by ball model:
#the input of the model is the ball result obtained during the prediction
def res_cat(x):
  #classes - 0,1,2,3
  class0 = ['0']#the category class - 0,consists of the classes in the list
  class1 = ['1','2','3']#the category class - 1,consists of runs 1,2,3
  class2 = ['4','6']#the category class 2,consists of boundaries 4,6
  class3 = ['W']#the category class 3 consists of class wickets
  #for now a static result of random generation is considered
  if x == 0:
    return np.random.choice(class0)
  elif x == 1:
     return np.random.choice(class1)
  elif x == 2:
    return np.random.choice(class2)
  else:
    return np.random.choice(class3)

#function to get the rfm batting cluster of the batsman:
#the input of this function is the player name and the year:
def rfm_bat_cluster(name,year):
  x = name
  #the df2 variable is the dataframe of the player_inof_unique.csv and is subsetted using the player name
  dv = df2[(df2.alpha_name == x)|(df2.card_long == x)|(df2.card_short == x)|(df2.known_as == x)|(df2.mobile_name == x)|(df2.popular_name == x)]
  #then the player's cluster value is found by subsetting the bat_clus variable
  #the bat_clus variable is the batting_cluster csv file:
  if len(dv) == 0:
    df1 = bat_clus[bat_clus.Batsman == x]
  else:
    #the short name of the player is obtained and subsetted
    sht = dv['card_long'].iloc[0]
    df1 = bat_clus[(bat_clus.Batsman == x)|(bat_clus.Batsman == sht)]
  #the year is considered as year-1 because few players may have not played in the current year,so in that case we consider year-1 as year and subset the dataset further:
  year = year - 1 
  df1 = df1[df1.year >= year]
  # the dataframe is then sorted in decending order with respect to year:
  df1 = df1.sort_values(by='year',ascending=False)
  # then the cluster value is returned: 
  if len(df1) > 0:
    clus = df1.cluster.iloc[0]
  else:
    clus = 0
  return clus

#function to get the rfm bowling cluster of the batsman:
#the input of this function is the player name and the year:
def rfm_bowl_cluster(name,year):
  x = name
  #the df2 variable is the dataframe of the player_inof_unique.csv and is subsetted using the player name
  dv = df2[(df2.alpha_name == x)|(df2.card_long == x)|(df2.card_short == x)|(df2.known_as == x)|(df2.mobile_name == x)|(df2.popular_name == x)]
  #then the player's cluster value is found by subsetting the bowl_clus variable
  #the bowl_clus variable is the bowling_cluster csv file:
  if len(dv) == 0:
    df1 = bowl_clus[bowl_clus.bowler == x]
  else:
    #the short name of the player is obtained and subsetted
    sht = dv['card_long'].iloc[0]
    df1 = bowl_clus[(bowl_clus.bowler == x)|(bowl_clus.bowler == sht)]
  #the year is considered as year-1 because few players may have not played in the current year,so in that case we consider year-1 as year and subset the dataset further:
  year = year - 1 
  df1 = df1[df1.year >= year]
  # the dataframe is then sorted in decending order with respect to year:
  df1 = df1.sort_values(by='year',ascending=False)
  # then the cluster value is returned: 
  if len(df1) > 0:
    clus = df1.cluster.iloc[0]
  else:
    clus = 0
  return clus

#function to get the simulation for innings 1:
#the input for this function is the innings number,batting team name,bowling team name,batting order of batting team,bowling order of bowling team,match number(static value for saving the dataframe in this match number)
def Ins_Mat_Sim(innings,bat_team,bowl_team,bat_order,bowl_order,match_no,year,venue):
    #an empty dataframe is created which will be iteratively added as the simulation goes on:
    df = pd.DataFrame()
    tdz = pd.DataFrame()
    #max_balls = 120
    #initializing the required variables:
    ball_no = 1#the ball number starts from 1
    over_no = 0#the over number stats from 0
    striker = bat_order[0]#the striker is the first player in the bat_order list
    non_striker = bat_order[1]#the striker is the second player in the bat_order list
    bowler = bowl_order[0]#the bowler is the first player in the bowl_order list
    cur_run = 0#before the start of the match the current run of the team is 0
    total_run = 0#before the start of the match the total run of the team is 0
    wic_count = 0#before the start of the match the wikcet count of the team is 0
    wic = 0#before the start of the match the wicket of the team is 0
    ball_count = 0#before the start of the match the ball count  is 0
    extras = 0#before the start of the match the extras is 0
    rrr = 0#before the start of the match the  required run rate of the team is 0
    crr = 0#before the start of the match the current run rate of the team is 0
    team_eco = 0#before the start of the match the economy of team is 0
    team_sr = 0#before the start of the match the strike rate of the team is 0
    while True:
        #start of simulation:
        try:
            bat_order.remove(striker)#the striker name is removed from the bat order to identify the next playing batsman
        except:
            pass
        try:
            bat_order.remove(non_striker)#the non striker name is removed from the bat order to identify the next playing batsman
        except:
            pass
        over = str(over_no)+'.'+str(ball_no)#the over is the float value of the ball for ex ==> 0.6 is the over i.e the last ball of first over
        first_innings_score = 0#since this is the first innings the first innings score is 0
        consistency_batsman_ = consistency_batsmen(striker)
        consistency_bowler_ = consistency_bowler(bowler)
        opposite_batsmen_ = opposition_batsmen(striker,bowl_team)
        opposite_bowler_ = opposition_bowler(bowler,bat_team)
        venue_batsmen_ = venue_batsmen(striker,venue)
        venue_bowler_ = venue_bowler(bowler,venue)
        form_batsmen_ = form_batsmen(striker,year)
        form_bowler_ = form_bowler(bowler,year)
        rfm_bat_cluster1 = rfm_bat_cluster(striker,year)#the rfm batting cluster of batsman
        rfm_bowl_cluster1 = rfm_bowl_cluster(bowler,year)#the rfm bowling cluster of the player
        if len(df) != 0:
          #if the simulation has had more than one balls finished,this condition executes:
          lb_extra = df['extra'].iloc[-1]#the last ball extras if any
          lb_run = df['Run'].iloc[-1]#the last ball's  runs scored off bat
          lb_rrr = df['RRR'].iloc[-1]#the last ball's required run rate
          lb_total_run = df['total_run'].iloc[-1]#the last ball's total run including extras
          lb_cur_run = df['cur_run'].iloc[-1]#the last ball's current run
          lb_strike_run_rate = df['str_rate'].iloc[-1]#the last ball's strike rate
          #the striker's match stats are subsetted for finding the batting momentum:
          striker_df = df[df.Striker == striker]
          lb_striker_cur_run = sum(striker_df.total_run)#striker's score as of last ball he faced
          try:
            lb_striker_strikerate = sum(striker_df.total_run)/len(striker_df)*100#the striker's strike rate as of last ball
          except:
            lb_striker_strikerate = 0
          #the non striker's match stats are subsetted for finding the batting momentum:
          nstriker_df = df[df.Non_Striker == non_striker]
          lb_non_striker_cur_run = sum(nstriker_df.total_run)#non striker's score as of last ball he faced
          try:
            lb_non_striker_strikerate  = sum(nstriker_df.total_run)/len(nstriker_df)*100#the non striker's strike rate as of last ball
          except:
            lb_non_striker_strikerate  = 0
          #the bowler's match stats are subsetted for finding the bowler in match stats:
          bowler_df = df[df.Bowler == bowler]
          try:
            ov_s = len(bowler_df)/6#overs bowled by bowler so far
            lb_bowler_economy = sum(bowler_df.total_run)/ov_s#economy of the bowler
          except:
            lb_bowler_economy = 0
          striker_df['bat_mom'] = striker_df['Run'].rolling(window = 6).mean()#striker's batting momentum
          striker_df.fillna(value = 0,inplace = True)
          try:
            lb_bat_mom = striker_df['bat_mom'].iloc[-1]#last ball of batting momentum of the striker
          except:
            lb_bat_mom = 0
          df['mat_mom'] = df['total_run'].rolling(window = 6).mean()#finding the match momentum  
          df['mat_mom'].fillna(value = 0,inplace = True)  
          try:
            lb_match_momentum =  df['mat_mom'].iloc[-1]#last ball's match momentum
          except:
            lb_match_momentum = 0
          lb_wicket = df['Wicket'].iloc[-1]#last ball's wicket status if any (is a binary value)
          lb_wicket_count = df['Wicket_Count'].iloc[-1]#last ball's wicket count i.e the number of wickets fallen as of last ball
          lb_team_crr = df['crr'].iloc[-1]#the current run rate of the team as off last ball
          lb_team_eco =  df['team_economy'].iloc[-1]#the bowling team economy as off last ball
          lb_team_sr =  df['team_sr'].iloc[-1]#the batting team strike rate as off last ball
          df = six_four_mom(df)#adding the six and four momentum as the match progresses:
          lb_six_mom = df['six_momentum'].iloc[-1]#the six momentum as off last ball
          lb_four_mom = df['four_momentum'].iloc[-1]#the four momentum as off last ball
          lb_6_count = df['6_count'].iloc[-1]#the six count as off last ball
          lb_4_count = df['4_count'].iloc[-1]#the four count as off last ball
        else:
          #this condition is executed during the first ball of the simulation and the value of every attribute in this condition will be zero since the match has not started yet!!
          lb_extra = 0
          lb_run = 0
          lb_rrr = 0
          lb_total_run = 0
          lb_cur_run = 0
          lb_strike_run_rate = 0
          lb_striker_cur_run = 0
          lb_striker_strikerate = 0
          lb_non_striker_cur_run = 0
          lb_non_striker_strikerate  = 0
          lb_bowler_economy = 0
          lb_bat_mom = 0
          lb_match_momentum =  0
          lb_wicket = 0
          lb_wicket_count = 0
          lb_team_crr = 0
          lb_team_eco =  0
          lb_team_sr = 0
          lb_six_mom = 0
          lb_four_mom = 0
          lb_6_count = 0
          lb_4_count = 0
        #the player info is collected as these attributes are considered in the model:
        stri_inf = batsman_in_match_info(striker)
        try:
          S_Bat_left = stri_inf[0]#the encoding (binary value),for batting hand
        except:
          S_Bat_left = 0 
        try:
          S_Bat_right = stri_inf[1]#the encoding (binary value),for batting hand
        except:
          S_Bat_right = 0
        #the info for the non striker is collected:
        nstri_inf = batsman_in_match_info(non_striker)
        try:
          NS_Bat_left = nstri_inf[0]#the encoding (binary value),for batting hand
        except:
          NS_Bat_left = 0
        try:
          NS_Bat_right = nstri_inf[1] #the encoding (binary value),for batting hand
        except:
          NS_Bat_right = 0
        #bowler's info is collected:
        bwl_inf = bowler_in_match_info(bowler)
        try:
          bwl_Bow_left =  bwl_inf[0] #the encoding (binary value),for bowling hand
        except:
          bwl_Bow_left = 0
        try:
          bwl_Bow_right = bwl_inf[1] #the encoding (binary value),for bowling hand
        except:
          bwl_Bow_right = 0
        try:
          Bowler_pace = bwl_inf[2] #the encoding (binary value),for bowling pace type of the player
        except:
          Bowler_pace = 0
        try:
          Bowler_spin = bwl_inf[3]#the encoding (binary value),for bowling pace type of the player
        except:
          Bowler_spin = 0 
        #the phase of the match is categorically encoded:
        if over_no <= 10:#the overs 1-10 is considered as powerplay overs
          Phase_death = 0
          Phase_middle = 0 
          Phase_power = 1
        elif over_no > 10 and over_no < 16:#overs 11-15 is considered middle overs
          Phase_death = 0
          Phase_middle = 1 
          Phase_power = 0
        else:#overs 16-20 is the death overs
          Phase_death = 1
          Phase_middle = 0 
          Phase_power = 0
        striker_age = stri_inf[2]#the striker age 
        striker_primary_role = stri_inf[3]#striker's primary role
        non_striker_age = nstri_inf[2]#non striker's age
        non_striker_primary_role = nstri_inf[3]#non striker's primary role
        bowler_age = bwl_inf[4]#bowler's age
        bowler_bowling_style = bwl_inf[5]#bowler's bowling style 
        bowler_primary_role = bwl_inf[6]#bowler's primary playing role
        #######model goes here########
        #result = np.random.choice(['0','1','2','3','4','6','W'])
        #the test list is the input features for the ball by ball prediction model:
        test = [[float(over), innings, first_innings_score, striker_age, striker_primary_role, 
                 non_striker_age, non_striker_primary_role, bowler_age, bowler_bowling_style, bowler_primary_role, 
                 consistency_batsman_, consistency_bowler_, opposite_batsmen_, opposite_bowler_, venue_batsmen_, venue_bowler_, form_batsmen_, form_bowler_,
                 lb_extra, lb_run, lb_rrr, lb_total_run, lb_cur_run, lb_strike_run_rate, lb_striker_cur_run, lb_non_striker_cur_run, lb_striker_strikerate,
                 lb_non_striker_strikerate, lb_bowler_economy, rfm_bat_cluster1, rfm_bowl_cluster1, lb_bat_mom, lb_six_mom, lb_four_mom, lb_match_momentum, 
                 lb_wicket, lb_wicket_count, lb_6_count, lb_4_count, lb_team_crr, lb_team_eco, lb_team_sr, S_Bat_left, S_Bat_right, NS_Bat_left, 
                 NS_Bat_right, bwl_Bow_left, bwl_Bow_right, Bowler_pace, Bowler_spin,Phase_death, Phase_middle, Phase_power]]
        print("test data === \n",test)
        dic_samp = {'over':float(over), 'innings':innings, 'first_innings_score':first_innings_score, 'striker_age':striker_age, 'striker_primary_role':striker_primary_role, 
                 'non_striker_age':non_striker_age, 'non_striker_primary_role':non_striker_primary_role, 'bowler_age':bowler_age, 'bowler_bowling_style':bowler_bowling_style,
                  'bowler_primary_role':bowler_primary_role, 
                 'consistency_batsman_':consistency_batsman_, 'consistency_bowler_':consistency_bowler_, 'opposite_batsmen_':opposite_batsmen_, 'opposite_bowler_':opposite_bowler_,
                  'venue_batsmen_':venue_batsmen_, 'venue_bowler_':venue_bowler_, 'form_batsmen_':form_batsmen_, 'form_bowler_':form_bowler_,
                 'lb_extra':lb_extra, 'lb_run':lb_run, 'lb_rrr':lb_rrr, 'lb_total_run':lb_total_run, 'lb_cur_run':lb_cur_run, 'lb_strike_run_rate':lb_strike_run_rate,
                 'lb_striker_cur_run': lb_striker_cur_run, 'lb_non_striker_cur_run':lb_non_striker_cur_run, 'lb_striker_strikerate':lb_striker_strikerate,
                 'lb_non_striker_strikerate':lb_non_striker_strikerate, 'lb_bowler_economy':lb_bowler_economy, 'rfm_bat_cluster1':rfm_bat_cluster1, 'rfm_bowl_cluster1':rfm_bowl_cluster1,
                  'lb_bat_mom':lb_bat_mom, 'lb_six_mom':lb_six_mom, 'lb_four_mom':lb_four_mom, 'lb_match_momentum':lb_match_momentum, 
                 'lb_wicket':lb_wicket, 'lb_wicket_count':lb_wicket_count, 'lb_6_count':lb_6_count, 'lb_4_count':lb_4_count, 'lb_team_crr':lb_team_crr, 'lb_team_eco':lb_team_eco,
                  'lb_team_sr':lb_team_sr, 'S_Bat_left':S_Bat_left, 'S_Bat_right':S_Bat_right, 'NS_Bat_left':NS_Bat_left, 
                 'NS_Bat_right':NS_Bat_right, 'bwl_Bow_left':bwl_Bow_left, 'bwl_Bow_right':bwl_Bow_right, 'Bowler_pace':Bowler_pace, 'Bowler_spin':Bowler_spin,'Phase_death':Phase_death,
                  'Phase_middle':Phase_middle, 'Phase_power':Phase_power}
        dic_samp_df = pd.DataFrame([dic_samp])
        tdz = pd.concat([tdz,dic_samp_df],axis=0)
        print(">>>"*30)
        print(dic_samp)
        print(">>>"*30)
        if ball_no == 1:
          pred = 1
          result = res_cat(pred)
        else:
          model = match_simulator_model()#calling the trained ball by ball prediction model
          pred = model.predict(test)#predicting the outcome of the ball
          result = res_cat(pred[0])#the ball result is then inversely transformed
        #pred =  np.random.choice([0,1,2,3])
        #result = res_cat(pred)
        print("Ball result ===>",result)
        ###############################
        cur_run = ball_result_cat(result)#the current run of the ball
        #if the ball result is a wicket then the wicket count and the wic is increased by +1 
        if result == 'W':
            wic = 1
            wic_count+=1
        else:
            wic = 0
        #condition for extra runs
        if result == 'extra':
            extras = 1
        else:
            extras = 0
        total_run = cur_run+extras#total runs is the sum of current run off bat and extras
        try:
          score = sum(df.total_run)+total_run#the team's total score
        except:
          score = 0
        try:
          sr = sum(df.total_run)/len(df)*100#the strike rate of the team
        except:
          sr = 0
        try:
          ov_s1 = len(df)/6
          crr = sum(df.total_run)/ov_s1#the current run rate of the team
        except:
          crr = 0
        team_eco = crr#the team economy is the same as the current run rate
        try:
          team_sr = sum(df.total_run)/len(df)*100#the team strike rate
        except:
          team_sr = 0
        #the features are stored as a list and then converted into a dataframe and finally concated with the main ball by ball dataframe of the innings
        dic = {'ESPN_ID':match_no,'Venue':venue,'Over_No':over,'Over1':over_no,'Innings':innings,'Striker':striker,'Non_Striker':non_striker,'Bowler':bowler,'Run':cur_run,
             'Wicket':wic,'Wicket_Count':wic_count,'Ball_Result':result,'Batting_Team':bat_team,'Bowling_Team':bowl_team,'first_innings_score':first_innings_score,
             'extra':extras,'RRR':rrr,'total_run':total_run,'cur_run':score,'str_rate':sr,'crr':crr,'team_economy':team_eco,'team_sr':team_sr,
             }
        dic1 = pd.DataFrame([dic])
        df = pd.concat([df,dic1])
        try:
            #the player status function returns with the next playing striker,non striker and bowler names
            nxt = player_status(result,ball_no,over_no,striker,non_striker,bowler,bat_order,bowl_order)
        except:
            pass
        try:
            striker = nxt[0]#striker name
        except:
            pass
        try:
            non_striker = nxt[1]#non striker name
        except:
            pass
        try:
            bowler = nxt[2]#bowler name
        except:
            pass
        #if its the last ball then the over number is added by +1 and the ball number is set as 1
        if ball_no == 6:
            ball_no = 1
            over_no+=1
            try:
                bowl_order.remove(bowler)#once the current over is finished then the bowler's name is removed from the current bowling order
                print("==="*20)
                print(bowl_order)
            except:
                pass
        else:
            ball_no+=1#after each iteration within the over the ball number is added by 1
        if result == 'wide':
            pass
        else:
            ball_count+=1
        rem_balls = 120 - ball_count#the remaining ball is calculated by 120 balls minus the current ball count ,where ball count is the number of balls simulated so far.
        #if the wicket count of the batting team is 10 or the remaining balls is 0 then the loop is broken and returns a dataframe of for the simulated balls.
        if wic_count == 10 or rem_balls == 0:
            break
    df.columns = ['ESPN_ID', 'Venue', 'Over_No', 'Over1', 'Innings', 'Striker', 'Non_Striker', 'Bowler', 'Runs', 'Wicket', 'Wicket_Count', 'Ball_Result', 'Batting_Team', 'Bowling_Team', 'first_innings_score', 'extra', 'RRR',  'cur_run','Total_Runs', 'str_rate', 'Current_Run_Rate', 'team_economy', 'team_sr', 'mat_mom', '4_count', '6_count', 'six_momentum', 'four_momentum']
    return df,tdz

#function to get the simulation for innings 2:
#the input for this function is the innings number,batting team name,bowling team name,batting order of batting team,bowling order of bowling team,first innings simulation dataframe,match number(static value for saving the dataframe in this match number)
#the functionality of this function is same as Ins_Mat_Sim function
def Ins_2_Mat_Sim(innings,bat_team,bowl_team,bat_order,bowl_order,first_ins_df,match_no,year,venue):
    target = sum(first_ins_df.cur_run)#the target is the sum of the first innings runs scored
    first_innings_score = target#the first innings score is the same as the target
    #an empty dataframe is created which will be iteratively added as the simulation goes on:
    df = pd.DataFrame()
    tdz = pd.DataFrame()
    #max_balls = 120
    #initializing the required variables:
    ball_no = 1
    over_no = 0
    striker = bat_order[0]
    non_striker = bat_order[1]
    bowler = bowl_order[0]
    cur_run = 0
    total_run = 0
    wic_count = 0
    wic = 0
    ball_count = 0
    extras = 0
    rrr = (target/120)*6
    crr = 0
    team_eco = 0
    team_sr = 0
    while True:
        
        try:
            bat_order.remove(striker)
        except:
            pass
        try:
            bat_order.remove(non_striker)
        except:
            pass
        over = str(over_no)+'.'+str(ball_no)
        consistency_batsman_ = consistency_batsmen(striker)
        consistency_bowler_ = consistency_bowler(bowler)
        opposite_batsmen_ = opposition_batsmen(striker,bowl_team)
        opposite_bowler_ = opposition_bowler(bowler,bat_team)
        venue_batsmen_ = venue_batsmen(striker,venue)
        venue_bowler_ = venue_bowler(bowler,venue)
        form_batsmen_ = form_batsmen(striker,year)
        form_bowler_ = form_bowler(bowler,year)
        rfm_bat_cluster1 = rfm_bat_cluster(striker,year)#the rfm batting cluster of batsman
        rfm_bowl_cluster1 = rfm_bowl_cluster(bowler,year)#the rfm bowling cluster of the player
        if len(df) != 0:
          lb_extra = df['extra'].iloc[-1]
          lb_run = df['Run'].iloc[-1]
          lb_rrr = df['RRR'].iloc[-1]
          lb_total_run = df['total_run'].iloc[-1]
          lb_cur_run = df['cur_run'].iloc[-1]
          lb_strike_run_rate = df['str_rate'].iloc[-1]
          striker_df = df[df.Striker == striker]
          lb_striker_cur_run = sum(striker_df.total_run)
          try:
            lb_striker_strikerate = sum(striker_df.total_run)/len(striker_df)*100
          except:
            lb_striker_strikerate = 0
          nstriker_df = df[df.Non_Striker == non_striker]
          lb_non_striker_cur_run = sum(nstriker_df.total_run)
          try:
            lb_non_striker_strikerate  = sum(nstriker_df.total_run)/len(nstriker_df)*100
          except:
            lb_non_striker_strikerate  = 0
          bowler_df = df[df.Bowler == bowler]
          try:
            ov_s = len(bowler_df)/6
            lb_bowler_economy = sum(bowler_df.total_run)/ov_s
          except:
            lb_bowler_economy = 0
          striker_df['bat_mom'] = striker_df['Run'].rolling(window = 6).mean()
          striker_df.fillna(value = 0,inplace = True)
          try:
            lb_bat_mom = striker_df['bat_mom'].iloc[-1]
          except:
            lb_bat_mom = 0
          df['mat_mom'] = df['total_run'].rolling(window = 6).mean()
          df['mat_mom'].fillna(value = 0,inplace = True)  
          try:
            lb_match_momentum =  df['mat_mom'].iloc[-1]
          except:
            lb_match_momentum = 0
          lb_wicket = df['Wicket'].iloc[-1]
          lb_wicket_count = df['Wicket_Count'].iloc[-1]
          lb_team_crr = df['crr'].iloc[-1]
          lb_team_eco =  df['team_economy'].iloc[-1]
          lb_team_sr =  df['team_sr'].iloc[-1]
          df = six_four_mom(df)
          lb_six_mom = df['six_momentum'].iloc[-1]
          lb_four_mom = df['four_momentum'].iloc[-1]
          lb_6_count = df['6_count'].iloc[-1]
          lb_4_count = df['4_count'].iloc[-1]
        else:
          lb_extra = 0
          lb_run = 0
          lb_rrr = 0
          lb_total_run = 0
          lb_cur_run = 0
          lb_strike_run_rate = 0
          lb_striker_cur_run = 0
          lb_striker_strikerate = 0
          lb_non_striker_cur_run = 0
          lb_non_striker_strikerate  = 0
          lb_bowler_economy = 0
          lb_bat_mom = 0
          lb_match_momentum =  0
          lb_wicket = 0
          lb_wicket_count = 0
          lb_team_crr = 0
          lb_team_eco =  0
          lb_team_sr = 0
          lb_six_mom = 0
          lb_four_mom = 0
          lb_6_count = 0
          lb_4_count = 0
        stri_inf = batsman_in_match_info(striker)
        try:
          S_Bat_left = stri_inf[0]
        except:
          S_Bat_left = 0 
        try:
          S_Bat_right = stri_inf[1]
        except:
          S_Bat_right = 0
        nstri_inf = batsman_in_match_info(non_striker)
        try:
          NS_Bat_left = nstri_inf[0]
        except:
          NS_Bat_left = 0
        NS_Bat_right = nstri_inf[1] 
        bwl_inf = bowler_in_match_info(bowler)
        try:
          bwl_Bow_left =  bwl_inf[0]
        except:
          bwl_Bow_left = 0
        try:
          bwl_Bow_right = bwl_inf[1]
        except:
          bwl_Bow_right = 0
        try:
          Bowler_pace = bwl_inf[2]
        except:
          Bowler_pace = 0
        try:
          Bowler_spin = bwl_inf[3]
        except:
          Bowler_spin = 0 
        if over_no < 10:
          Phase_death = 0
          Phase_middle = 0 
          Phase_power = 1
        elif over_no >= 10 and over_no < 16:
          Phase_death = 0
          Phase_middle = 1 
          Phase_power = 0
        else:
          Phase_death = 1
          Phase_middle = 0 
          Phase_power = 0
        striker_age = stri_inf[2]
        striker_primary_role = stri_inf[3]
        non_striker_age = nstri_inf[2]
        non_striker_primary_role = nstri_inf[3]
        bowler_age = bwl_inf[4]
        bowler_bowling_style = bwl_inf[5] 
        bowler_primary_role = bwl_inf[6]
        #######model goes here########
        #result = np.random.choice(['0','1','2','3','4','6','W'])

        test = [[float(over), innings, first_innings_score, striker_age, striker_primary_role, 
                 non_striker_age, non_striker_primary_role, bowler_age, bowler_bowling_style, bowler_primary_role, 
                 consistency_batsman_, consistency_bowler_, opposite_batsmen_, opposite_bowler_, venue_batsmen_, venue_bowler_, form_batsmen_, form_bowler_,
                 lb_extra, lb_run, lb_rrr, lb_total_run, lb_cur_run, lb_strike_run_rate, lb_striker_cur_run, lb_non_striker_cur_run, lb_striker_strikerate,
                 lb_non_striker_strikerate, lb_bowler_economy, rfm_bat_cluster1, rfm_bowl_cluster1, lb_bat_mom, lb_six_mom, lb_four_mom, lb_match_momentum, 
                 lb_wicket, lb_wicket_count, lb_6_count, lb_4_count, lb_team_crr, lb_team_eco, lb_team_sr, S_Bat_left, S_Bat_right, NS_Bat_left, 
                 NS_Bat_right, bwl_Bow_left, bwl_Bow_right, Bowler_pace, Bowler_spin,Phase_death, Phase_middle, Phase_power]]
        dic_samp = {'over':float(over), 'innings':innings, 'first_innings_score':first_innings_score, 'striker_age':striker_age, 'striker_primary_role':striker_primary_role, 
                 'non_striker_age':non_striker_age, 'non_striker_primary_role':non_striker_primary_role, 'bowler_age':bowler_age, 'bowler_bowling_style':bowler_bowling_style,
                  'bowler_primary_role':bowler_primary_role, 
                 'consistency_batsman_':consistency_batsman_, 'consistency_bowler_':consistency_bowler_, 'opposite_batsmen_':opposite_batsmen_, 'opposite_bowler_':opposite_bowler_,
                  'venue_batsmen_':venue_batsmen_, 'venue_bowler_':venue_bowler_, 'form_batsmen_':form_batsmen_, 'form_bowler_':form_bowler_,
                 'lb_extra':lb_extra, 'lb_run':lb_run, 'lb_rrr':lb_rrr, 'lb_total_run':lb_total_run, 'lb_cur_run':lb_cur_run, 'lb_strike_run_rate':lb_strike_run_rate,
                 'lb_striker_cur_run': lb_striker_cur_run, 'lb_non_striker_cur_run':lb_non_striker_cur_run, 'lb_striker_strikerate':lb_striker_strikerate,
                 'lb_non_striker_strikerate':lb_non_striker_strikerate, 'lb_bowler_economy':lb_bowler_economy, 'rfm_bat_cluster1':rfm_bat_cluster1, 'rfm_bowl_cluster1':rfm_bowl_cluster1,
                  'lb_bat_mom':lb_bat_mom, 'lb_six_mom':lb_six_mom, 'lb_four_mom':lb_four_mom, 'lb_match_momentum':lb_match_momentum, 
                 'lb_wicket':lb_wicket, 'lb_wicket_count':lb_wicket_count, 'lb_6_count':lb_6_count, 'lb_4_count':lb_4_count, 'lb_team_crr':lb_team_crr, 'lb_team_eco':lb_team_eco,
                  'lb_team_sr':lb_team_sr, 'S_Bat_left':S_Bat_left, 'S_Bat_right':S_Bat_right, 'NS_Bat_left':NS_Bat_left, 
                 'NS_Bat_right':NS_Bat_right, 'bwl_Bow_left':bwl_Bow_left, 'bwl_Bow_right':bwl_Bow_right, 'Bowler_pace':Bowler_pace, 'Bowler_spin':Bowler_spin,'Phase_death':Phase_death,
                  'Phase_middle':Phase_middle, 'Phase_power':Phase_power}
        dic_samp_df = pd.DataFrame([dic_samp])
        tdz = pd.concat([tdz,dic_samp_df],axis=0)
        print(">>>"*30)
        print(dic_samp)
        print(">>>"*30)
        if ball_no == 1:
          pred = 1
          result = res_cat(pred)
        else:
          model = match_simulator_model()
          pred = model.predict(test)
          result = res_cat(pred[0])
        #pred =  np.random.choice([0,1,2,3])
        #result = res_cat(pred)
        print("Ball result ===>",result)
        ###############################
        cur_run = ball_result_cat(result)
        if result == 'W':
            wic = 1
            wic_count+=1
        else:
            wic = 0
        if result == 'extra':
            extras = 1
        else:
            extras = 0
        total_run = cur_run+extras
        try:
          score = sum(df.total_run)+total_run
        except:
          score = 0
        try:
          sr = sum(df.total_run)/len(df)*100
        except:
          sr = 0
        try:
          ov_s1 = len(df)/6
          crr = sum(df.total_run)/ov_s1
        except:
          crr = 0
        team_eco = crr
        try:
          team_sr = sum(df.total_run)/len(df)*100
        except:
          team_sr = 0
        target1 = target - score
        rrr = (target1/120)*6
        team_eco = crr
        dic = {'ESPN_ID':match_no,'Venue':venue,'Over_No':over,'Over1':over_no,'Innings':innings,'Striker':striker,'Non_Striker':non_striker,'Bowler':bowler,'Run':cur_run,
             'Wicket':wic,'Wicket_Count':wic_count,'Ball_Result':result,'Batting_Team':bat_team,'Bowling_Team':bowl_team,'first_innings_score':first_innings_score,
             'extra':extras,'RRR':rrr,'total_run':total_run,'cur_run':score,'str_rate':sr,'crr':crr,'team_economy':team_eco,'team_sr':team_sr,
             }
        dic1 = pd.DataFrame([dic])
        df = pd.concat([df,dic1])
        try:
            nxt = player_status(result,ball_no,over_no,striker,non_striker,bowler,bat_order,bowl_order)
        except:
            pass
        try:
            striker = nxt[0]
        except:
            pass
        try:
            non_striker = nxt[1]
        except:
            pass
        try:
            bowler = nxt[2]
        except:
            pass
        if ball_no == 6:
            ball_no = 1
            over_no+=1
            try:
                bowl_order.remove(bowler)
                print("==="*20)
                print(bowl_order)
            except:
                pass
        else:
            ball_no+=1
        if result == 'wide':
            pass
        else:
            ball_count+=1
        rem_balls = 120 - ball_count
        tm_score = sum(df.total_run)
        if wic_count == 10 or rem_balls == 0:
            break
        if tm_score > target:
            break
    df.columns = ['ESPN_ID', 'Venue', 'Over_No', 'Over1', 'Innings', 'Striker', 'Non_Striker', 'Bowler', 'Runs', 'Wicket', 'Wicket_Count', 'Ball_Result', 'Batting_Team', 'Bowling_Team', 'first_innings_score', 'extra', 'RRR',  'cur_run','Total_Runs', 'str_rate', 'Current_Run_Rate', 'team_economy', 'team_sr', 'mat_mom', '4_count', '6_count', 'six_momentum', 'four_momentum']
    return df,tdz

#main function for the match simulation:
#the input for this function is the team names,venue name,team1 squad ,team 2 squad,match id(dummy variable for storing the csv file in this name or number),year of the match.
def MatchSimulator(team1,team2,venue,team1squad,team2squad,match_id,year):
    #generating toss:
    toss_res = toss(team1,team2)#a random toss is generated using the toss function 
    toss_winner = toss_res['toss_winner']#the toss winner name
    toss_decision = toss_res['toss_decision']#the toss decision(bat or field)
    print("!!!"*30)
    print("Toss - ")
    print(toss_res['description'])#the toss description
    #condition for setting the batting and bowling team
    if toss_winner == team1:
        if toss_decision == 'bat':
            bating_team = team1
            bowling_team = team2
        else:
            bating_team = team2
            bowling_team = team1
    else:
        if toss_decision == 'bat':
            bating_team = team2
            bowling_team = team1
        else:
            bating_team = team1
            bowling_team = team2
    
    #generating squad combinations for both the team:
    print("generating player combinations ... ")
    t1_combs = team_comb(team1squad,team1)#combination of 11 players in team1 squad
    t2_combs = team_comb(team2squad,team2)#combination of 11 players in team2 squad
    print("===="*30)
    print("No of combinations in team1 = ",len(t1_combs))
    print("No of combinations in team2 = ",len(t2_combs))
    print("===="*30)
    print("Match simulation begin.......")
    count_sim = 0#the initial count of the number of simulation is set to 0 and added +1 after each iteration:
    for i in range(len(t1_combs)):#team1 squad combinations range
        for j in range(len(t2_combs)):#team2 squad combinations range
            count_sim+=1#the simulation number is incremented by 1
            print("%%%"*30)
            print("Simulation number - ",count_sim)
            print("%%%"*30)
            #generating batting and bowling order for the teams:
            t1_batorder = bat_order(t1_combs[i])#the batting order of team1
            t1_bowlorder = bowl_order(t1_combs[i])#the bowling order of team1(returns a dataframe)
            t1_bowlorder = bowling_overs(t1_bowlorder)#the bowling order of team1
            t2_batorder = bat_order(t2_combs[j])#the batting order of team2
            t2_bowlorder = bowl_order(t2_combs[j])#the bowling order of team2(returns a dataframe)
            t2_bowlorder = bowling_overs(t2_bowlorder)#the bowling order of team2
            #simulation for innings 1:
            print("Innings 1.....")
            bat_team1 = bating_team#batting team name
            bowl_team1 = bowling_team#bowling team name
            innings = 1
            if bat_team1 == team1:
                bat_order1 = t1_batorder
                bowl_order1 = t2_bowlorder
            else:
                bat_order1 = t2_batorder
                bowl_order1 = t1_bowlorder
            #the ins1_df runs the first innings simulation and returns a dataframe simulated for 1st innings:
            ins1_df = Ins_Mat_Sim(innings,bat_team1,bowl_team1,bat_order1,bowl_order1,match_id,year,venue)
            print("end of innings 1....")
            #simulation for innings 2:
            print("---"*30)
            print("Innings 2......")
            bat_team2 = bowling_team
            bowl_team2 = bating_team
            innings = 2
            if bat_team2 == team1:
                bat_order2 = t1_batorder
                bowl_order2 = t2_bowlorder
            else:
                bat_order2 = t2_batorder
                bowl_order2 = t1_bowlorder
            #the ins2_df runs the second innings simulation and returns a dataframe simulated for 2nd innings:  
            ins2_df = Ins_2_Mat_Sim(innings,bat_team2,bowl_team2,bat_order2,bowl_order2,ins1_df[0],match_id,year,venue)
            print("End of Innings....")
            print('----'*30)
            #concating both the first innings and the second innings dataframe:
            df = pd.concat([ins1_df[0],ins2_df[0]],axis=0)
            #finally the simulated match is saved as a csv in the specified directory.
            team1+"_vs_"+team2+"_"+str(match_id)+"_"+str(count_sim)+".csv"
            df.to_csv(loc_df+team1+"_vs_"+team2+"_"+str(match_id)+"_"+str(count_sim)+".csv",index = False)
            #df.to_csv(loc_df+str(match_id)+'_'+'match_sim_'+str(count_sim)+'.csv',index = False)
            #df34 = pd.concat([ins1_df[1],ins2_df[1]],axis=0)
            #df34.to_csv(loc_df+str(match_id)+'_'+'match_input_'+str(count_sim)+'.csv',index = False)

#testing for one match:
import time
t1 = time.monotonic()
team1 = 'Mumbai Indians'
team2 = 'Chennai Super Kings'
venue = 'Wankadhe stadium'
match_id = 10111
year = 2021
team1squad = ['RG Sharma', 'Q de Kock', 'SA Yadav', 'SS Tiwary', 'HH Pandya',
       'KA Pollard', 'KH Pandya', 'JL Pattinson', 'RD Chahar', 'TA Boult',
       'JJ Bumrah', 'Ishan Kishan', 'NM Coulter-Nile', 'DS Kulkarni',
       'CA Lynn', 'Jayant Yadav', 'Piyush Chawla', 'Saurabh Tiwary', 'Aditya Tare', 'Adam Milne', 'Chris Lynn', 
              'Ishan Kishan', 'Anmolpreet Singh', 'Anukul Roy', 'Mohsin Khan', 'Arjun Tendulkar', 'Marco Jansen', 'Yudhvir Singh' ]
team1squad = filter_15_players(team1squad)
print(team1squad)
team2squad = ['SM Curran', 'F du Plessis',  'AT Rayudu', 'MS Dhoni',
       'RA Jadeja', 'DJ Bravo', 'DL Chahar',  'RD Gaikwad',
        'SN Thakur', 'Imran Tahir', 'MM Ali', 'SK Raina','L Ngidi' 'Robin Uthappa', 'Cheteshwar Pujara', 'Karn Sharma', 'Jason Behrendorff',
              'Krishnappa Gowtham', 'Mitchell Santner', 'Ravisrinivasan Sai Kishore', 'Hari Nishanth', 'N Jagadeesan',
              'KM Asif', 'Harishankar Reddy', 'Bhagath Varma' ]
team2squad = filter_15_players(team2squad)
MatchSimulator(team1,team2,venue,team1squad,team2squad,match_id,year)
t2 = time.monotonic()
print("=="*30)
print("time taken = ",t2-t1)
print("=="*30)

